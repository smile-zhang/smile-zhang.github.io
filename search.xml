<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MyBatis</title>
      <link href="/2022/02/05/MyBatis/"/>
      <url>/2022/02/05/MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>MyBatis  做为服务端开发最常采用的一种ORM框架，支持定制化 SQL、存储过程以及高级映射。并避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>本文将详细讲述 MyBatis 从最基础的 安装、使用，到源码分析 与整合 Spring后的工作原理。</p><span id="more"></span><h1 id="基础（涉及）"><a href="#基础（涉及）" class="headerlink" title="基础（涉及）"></a>基础（涉及）</h1><h2 id="使用-MyBatis"><a href="#使用-MyBatis" class="headerlink" title="使用 MyBatis"></a>使用 MyBatis</h2><ul><li><p>声明maven依赖，指定依赖版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置 mybatisConfig.xml</p><ul><li>声明数据源信息<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;org.myproject.C3P0DataSourceFactory&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.postgresql.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:postgresql:mydb&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;postgres&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>声明 Plugins</li><li>配置 事务管理器</li><li>其它配置</li><li>配置</li><li>声明 映射器（mappers），即mapping.xml 所在位置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定包：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--指定类名：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>开始使用</p><ol><li><p>创建主体类：User.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建映射文件：User.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">&lt;!-- mapper标签要指定namespace属性，不然会报错，可看做包名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.jimmy.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user4 where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建dao接口和实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 接口</span><br><span class="line">public interface UserDao &#123;  </span><br><span class="line">    public User findUserById(int id) throws Exception ;</span><br><span class="line">    public List&lt;User&gt; findAllUsers() throws Exception;</span><br><span class="line">    public void insertUser(User user) throws Exception;</span><br><span class="line">    public void deleteUserById(int id) throws Exception;</span><br><span class="line">    public void updateUserPassword(User user) throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类</span><br><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    public User findUserById(int id) throws Exception &#123;</span><br><span class="line">        //1.声明 配置文件位置</span><br><span class="line">        String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        //2.读取配置文件</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        //3.根据配置文件，创建会话（session)</span><br><span class="line">        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        //4.配置文件中声明了，&quot;user.findUserById&quot;，对应的sql，selectOne表示执行对应的sql</span><br><span class="line">        User user = session.selectOne(&quot;user.findUserById&quot;,id); //参数一：namespace.id           </span><br><span class="line">        //5.查询结束，关闭会话。</span><br><span class="line">        session.close();</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="整合-spring"><a href="#整合-spring" class="headerlink" title="整合 spring"></a>整合 spring</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>声明依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis-spring适配器 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>配置<ul><li>xml 配置方式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 1.声明数据源</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;datasource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.uid&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.pwd&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 2.声明 SqlSessionFactoryBean，并 将数据源注入</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;datasource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 3.声明 MapperScanConfigurer,在其中指定Mapper的包路径，用于自动扫描对象关系映射</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定会话工厂，如果当前上下文中只定义了一个则该属性可省去 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定要自动扫描接口的基础包，实现接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.zhangtao.bookstore.mapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>java bean 配置方式<h1 id="展开（论述）"><a href="#展开（论述）" class="headerlink" title="展开（论述）"></a>展开（论述）</h1><h2 id="MyBatis-源码分析"><a href="#MyBatis-源码分析" class="headerlink" title="MyBatis 源码分析"></a>MyBatis 源码分析</h2>MyBatis 基础运行代码如下，核心步骤为3步，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.加载配置文件</span></span><br><span class="line">String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line">inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span>        SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"><span class="comment">//2.创建sqlSession</span></span><br><span class="line">sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//3.获取映射对象</span></span><br><span class="line">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">System.out.println(userMapper.selectById(<span class="number">1</span>));</span><br><span class="line">     </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="创建sqlSession"><a href="#创建sqlSession" class="headerlink" title="创建sqlSession"></a>创建sqlSession</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 1.将 mybatis-config.xml 文件以流的形式传入</span><br><span class="line">org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream)</span><br><span class="line"></span><br><span class="line">// 2.经多次调用，到达此方法</span><br><span class="line">org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream, java.lang.String, java.util.Properties)</span><br><span class="line"></span><br><span class="line">// 3.调用parse方法返回 Configuration 对象的实例 </span><br><span class="line">XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">parser.parse();</span><br><span class="line">// 3.1  parse 方法 本质上是构建 Configuration 对象的实例，其中它还通过解析 xml 中的mapper 标签，将所有mapper加入到了一个map中;</span><br><span class="line">org.apache.ibatis.builder.xml.XMLConfigBuilder.parse</span><br><span class="line">org.apache.ibatis.builder.xml.XMLConfigBuilder.parseConfiguration</span><br><span class="line">org.apache.ibatis.builder.xml.XMLConfigBuilder.mapperElement</span><br><span class="line">else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123;</span><br><span class="line">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">// 4.这是最后一层调用，创建了 DefaultSqlSessionFactory 对象。即入口处的build方法，获得了一个SessionFactory</span><br><span class="line">org.apache.ibatis.session.SqlSessionFactoryBuilder#build(org.apache.ibatis.session.Configuration) </span><br><span class="line"></span><br><span class="line">// 5.使用 sqlSessionFactory 接口 ，接收build 方法的返回值，并调用 openSession。</span><br><span class="line">sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">// 6. openopenSession 方法中调用此方法</span><br><span class="line">org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource</span><br><span class="line"></span><br><span class="line">// 7. openSessionFromDataSource 的具体实现：</span><br><span class="line">// 7.1 创建事务管理器</span><br><span class="line">tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">// 7.2 创建执行器，</span><br><span class="line">final Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">// 7.3 新建 sqlSession并返回，</span><br><span class="line">return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>小结：</p><ul><li>事务管理器和sqlSession在同一方法中被创建，所以一个会话，处于同一事务</li><li>parse 方法 构建了 Configuration 对象的实例，还处理了所有的mapper：configuration.addMapper(mapperInterface);<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加载 所有 Mapper.xml 到MapperRegistry类中的 knownMappers 属性中。***这里使用了 工厂模式、代理模式***</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;();</span><br><span class="line"><span class="comment">// key ：UserMapper.class</span></span><br><span class="line"><span class="comment">// value ：MapperProxyFactory〈UserMapper.class〉</span></span><br><span class="line"><span class="comment">// 加载 所有 Mapper.xml后，调用 knownMappers.addMapper(Class, type) ,为每一个class创建一个代理工厂对象，并put 进其中。  </span></span><br></pre></td></tr></table></figure></li></ul><h3 id="从Session中-获取mapper"><a href="#从Session中-获取mapper" class="headerlink" title="从Session中 获取mapper."></a>从Session中 获取mapper.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1.调用 session.getMapper()</span><br><span class="line">org.apache.ibatis.session.defaults.DefaultSqlSession.getMapper</span><br><span class="line">// 2.本质上是调用了 Configuration 的 getMapper</span><br><span class="line">org.apache.ibatis.session.Configuration.getMapper</span><br><span class="line">// 3.具体实现为：即从 mapperRegistry 属性中 获取 mapper 对象，本质上获取到的是 mapper的一个代理工厂对象</span><br><span class="line">  return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">// 4. MapperRegistry 的 getMapper</span><br><span class="line">org.apache.ibatis.binding.MapperRegistry.getMapper</span><br><span class="line">// 4.1.具体实现</span><br><span class="line">  return mapperProxyFactory.newInstance(sqlSession);</span><br></pre></td></tr></table></figure><p>小结：本小节主要要掌握 mapper 接口是如何被 管理和使用的。</p><h2 id="MyBatis-整合Spring后-的源码分析"><a href="#MyBatis-整合Spring后-的源码分析" class="headerlink" title="MyBatis 整合Spring后 的源码分析"></a>MyBatis 整合Spring后 的源码分析</h2><h3 id="整合Spring后-Mapper自动注入原理的原理"><a href="#整合Spring后-Mapper自动注入原理的原理" class="headerlink" title="整合Spring后 Mapper自动注入原理的原理"></a>整合Spring后 Mapper自动注入原理的原理</h3><p>前言：InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。<br>所以 Spring 整合 MyBatis 也离不开这个类。</p><ol><li>SqlSessionFactoryBean：在引入mybatis-spring.jar后，我们需要在applicationContext.xml中配置 SqlSessionFactoryBean<br><img src="https://raw.githubusercontent.com/smile-zhang/blog-image/master/20220205/image.22vny50jkew0.webp" alt="image"><br>具体看一下本类：<br> <img src="https://raw.githubusercontent.com/smile-zhang/blog-image/master/20220205/image.340lxvwbyt40.webp" alt="image"><ol><li>FactoryBean：这是spring的工厂bean，我们获取bean的时候会得到它getObject方法返回的对象，只有在beanName前加上“$”才会获得FactoryBean本身的对象</li><li>InitializingBean：实现这个接口的bean在初始化之前会调用afterPropertiesSet方法；还有这种功能的有initMethod（），@PostConstract</li></ol></li></ol><p>看看afterPropertiesSet方法都做了什么<br>   <img src="https://raw.githubusercontent.com/smile-zhang/blog-image/master/20220205/image.8r3mwbk9pko.webp" alt="image"><br>buildSqlSessionFactory() 方法<br>   <img src="https://raw.githubusercontent.com/smile-zhang/blog-image/master/20220205/image.501ia0kun7k0.webp" alt="image"><br>如图，最终也是调用了 MyBatis 的 xmlConfigBuilder.parse(); 和 xmlMapperBuilder.parse(); 方法</p><ol start="2"><li>MapperScannerConfigurer：Spring 整合 MyBatis 的第二个核心配置。<br><img src="https://raw.githubusercontent.com/smile-zhang/blog-image/master/20220205/image.y8vtn6m48eo.webp" alt="image"><br>实现 BeanDefinitionRegistryPostProcessor 与 InitializingBean 接口<br><img src="https://raw.githubusercontent.com/smile-zhang/blog-image/master/20220205/image.2p10ynfuygy0.webp" alt="image"><br>重写 postProcessBeanDefinitionRegistry 方法，并调用 ClassPathMapperScanner 对象的scan()方法<br><img src="https://raw.githubusercontent.com/smile-zhang/blog-image/master/20220205/image.2jedylyitwq0.webp" alt="image"><br>scan()方法中调用了 子类的doScan，并在其中替换 BeanClass 为 MapperFactoryBean.class<br><img src="https://raw.githubusercontent.com/smile-zhang/blog-image/master/20220205/image.58p1pzx2urc0.webp" alt="image"><br>看看MapperFactoryBean都有些什么：</li><li><a href="https://blog.csdn.net/qq_41301079/article/details/102231881">详解可参考：https://blog.csdn.net/qq_41301079/article/details/102231881</a></li></ol><h3 id="执行mapper接口中的方法"><a href="#执行mapper接口中的方法" class="headerlink" title="执行mapper接口中的方法"></a>执行mapper接口中的方法</h3><h2 id="MyBatis-中的设计模式"><a href="#MyBatis-中的设计模式" class="headerlink" title="MyBatis 中的设计模式"></a>MyBatis 中的设计模式</h2><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>plugin 的调用</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>默认执行器 - 缓存执行器 - 插件执行器</p><h3 id="代理模块"><a href="#代理模块" class="headerlink" title="代理模块"></a>代理模块</h3><p>最终执行 preparedStatement.query()时，</p><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>通过抽象类来定义一个逻辑模板，逻辑框架、逻辑原型，然后将无法决定的部分抽象成抽象类交由子类来实现，一般这些抽象类的调用逻辑还是在抽象类中完成的</p><p>Executor</p><h3 id="MyBatis-本质上就是封装了jdbc，底层在执行时，还是调用的-preparedStatement"><a href="#MyBatis-本质上就是封装了jdbc，底层在执行时，还是调用的-preparedStatement" class="headerlink" title="MyBatis 本质上就是封装了jdbc，底层在执行时，还是调用的 preparedStatement"></a>MyBatis 本质上就是封装了jdbc，底层在执行时，还是调用的 preparedStatement</h3><h3 id="MyBatis-的一级缓存，只在当前会话中生效，又因为-每次创建会话，都会同步创建一个事务，所以等同于-一级缓存只在当前事务中生效"><a href="#MyBatis-的一级缓存，只在当前会话中生效，又因为-每次创建会话，都会同步创建一个事务，所以等同于-一级缓存只在当前事务中生效" class="headerlink" title="MyBatis 的一级缓存，只在当前会话中生效，又因为 每次创建会话，都会同步创建一个事务，所以等同于 一级缓存只在当前事务中生效"></a>MyBatis 的一级缓存，只在当前会话中生效，又因为 每次创建会话，都会同步创建一个事务，所以等同于 一级缓存只在当前事务中生效</h3><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea 使用技巧</title>
      <link href="/2021/12/01/idea%E6%8A%80%E5%B7%A7/"/>
      <url>/2021/12/01/idea%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>idea 作为JAVA开发最常用的开发工具，使用得当能够大幅度提高工作效率，我将在这篇bolg持续更新我在开发过程中遇到的问题，如配置/技巧/插件等。</p><span id="more"></span><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>我目前使用的激活方式是：无限试用插件 ** IDE Eval Reset **，使用方式非常简单，具体如下</p><ul><li>配置第三方插件仓库 ，内容为：<a href="https://plugins.zhile.io/">https://plugins.zhile.io</a> </li><li>搜索插件：IDE Eval Reset  ，安装并重启</li><li>安装成功后，每次重启idea都会重置试用时间为30天，达到无限试用的目标。<h2 id="配置（setting-）"><a href="#配置（setting-）" class="headerlink" title="配置（setting ）"></a>配置（setting ）</h2></li><li>自动优化导包<h2 id="插件（plugin）"><a href="#插件（plugin）" class="headerlink" title="插件（plugin）"></a>插件（plugin）</h2></li></ul><ul><li>汉化插件 ：chinese，全局汉化，初学者或英语较差的小伙伴可以尝试使用，但还是建议使用英文，毕竟目前教程更多的是针对英文的。 </li><li>无限试用：IDE Eval Reset 。开篇就提到的调用（激活）插件。<h2 id="工具（tools）"><a href="#工具（tools）" class="headerlink" title="工具（tools）"></a>工具（tools）</h2><h2 id="快捷键（keymap）"><a href="#快捷键（keymap）" class="headerlink" title="快捷键（keymap）"></a>快捷键（keymap）</h2></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ide </tag>
            
            <tag> idea </tag>
            
            <tag> plugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java锁机制</title>
      <link href="/2021/08/05/java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/08/05/java%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要:"></a>摘要:</h3><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，介绍主流锁的知识点，以及不同的锁的适用场景。  <span id="more"></span></p><p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：<br><img src="https://cdn.jsdelivr.net/gh/smile-zhang/blog-image@master/20210805/image.4kesadq2r760.png"></p><!-- more --><h2 id="1-锁的分类"><a href="#1-锁的分类" class="headerlink" title="1. 锁的分类"></a>1. 锁的分类</h2><h3 id="1-1-乐观锁-VS-悲观锁"><a href="#1-1-乐观锁-VS-悲观锁" class="headerlink" title="1.1 乐观锁 VS 悲观锁"></a>1.1 乐观锁 VS 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。  </p><p><strong>概念</strong>：  </p><ul><li><p><strong>悲观锁</strong>：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。  </p></li><li><p><strong>乐观锁</strong>：认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）  </p></li></ul><p>乐观锁在Java中是通过使用<strong>无锁编程</strong>来实现，最常采用的是<strong>CAS算法</strong>，Java原子类中的递增操作就通过CAS自旋实现的。<br><img src="https://cdn.jsdelivr.net/gh/smile-zhang/blog-image@master/20210805/image.675at5s2asg0.png">  </p><p><strong>小结</strong>：<br>根据从上面的概念描述我们可以发现：</p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。  </li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。  </li></ul><p><strong>代码</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ------------------------- 悲观锁的调用方式 -------------------------</span><br><span class="line">// synchronized</span><br><span class="line">public synchronized void testMethod() &#123;</span><br><span class="line">// 操作同步资源</span><br><span class="line">&#125;</span><br><span class="line">// ReentrantLock</span><br><span class="line">private ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁</span><br><span class="line">public void modifyPublicResources() &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">// 操作同步资源</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ------------------------- 乐观锁的调用方式 -------------------------</span><br><span class="line">private AtomicInteger atomicInteger = new AtomicInteger();  // 需要保证多个线程使用的是同一个AtomicInteger</span><br><span class="line">atomicInteger.incrementAndGet(); //执行自增1</span><br></pre></td></tr></table></figure><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？这就要了解 乐观锁的主要实现方式  “CAS”  的技术原理了。  </p><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。  </p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A(一般来说，是操作开始前，读取到的v的值)。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：<br><img src="https://cdn.jsdelivr.net/gh/smile-zhang/blog-image@master/20210805/image.3vym6emx6hi0.png"></p><p><a href="www.baidu.com">我在这篇文章中，对AtomicInteger进行了更深进一步的解读</a><br>根据定义我们可以看出各属性的作用：</p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。  </li></ul><p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// ------------------------- JDK 8 -------------------------</span><br><span class="line">// AtomicInteger 自增方法</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Unsafe.class</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">  int var5;</span><br><span class="line">  do &#123;</span><br><span class="line">      var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  return var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ------------------------- OpenJDK 8 -------------------------</span><br><span class="line">// Unsafe.java</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">   int v;</span><br><span class="line">   do &#123;</span><br><span class="line">       v = getIntVolatile(o, offset);</span><br><span class="line">   &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   return v;</span><br><span class="line">&#125;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><h2 id="2-基础（涉及）"><a href="#2-基础（涉及）" class="headerlink" title="2. 基础（涉及）"></a>2. 基础（涉及）</h2><h2 id="3-展开（论述）"><a href="#3-展开（论述）" class="headerlink" title="3. 展开（论述）"></a>3. 展开（论述）</h2><h2 id="4-解决（方案）"><a href="#4-解决（方案）" class="headerlink" title="4. 解决（方案）"></a>4. 解决（方案）</h2><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p><p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mac 使用问题</title>
      <link href="/2021/08/01/mac%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/08/01/mac%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0-摘要"><a href="#0-摘要" class="headerlink" title="0. 摘要"></a>0. 摘要</h2><p>win转mac使用两年左右的时间，还是有些问题需要重复搜索资料，为避免浪费时间，就在这里记录并分享一下，也希望能为遇到同样的问题的小伙伴提供帮助. </p><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
            <tag> mac </tag>
            
            <tag> linux </tag>
            
            <tag> pulgs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客（mac 环境 ）</title>
      <link href="/2021/07/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/07/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="0-摘要"><a href="#0-摘要" class="headerlink" title="0. 摘要"></a>0. 摘要</h2><p>最近正在使用 hexo 重新搭建博客,之前的内容会逐步更新上来.<br>相较于 Rube实现的 jekyll 性能更好， 且基于node.js实现的hexo的可扩展性也更好一些，所以尝试使用 hexo 重新搭建个人博客，之前的内容会逐步同步上来。</p><span id="more"></span><h2 id="1-基础环境的安装、升级与卸载"><a href="#1-基础环境的安装、升级与卸载" class="headerlink" title="1. 基础环境的安装、升级与卸载"></a>1. 基础环境的安装、升级与卸载</h2><h3 id="1-1-安装-node-、npm-、-hexo"><a href="#1-1-安装-node-、npm-、-hexo" class="headerlink" title="1.1  安装 node 、npm 、 hexo"></a>1.1  安装 node 、npm 、 hexo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">brew install npm</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install hexo-renderer-swig</span><br></pre></td></tr></table></figure><p>hexo-renderer-swig 这个依赖在 hexo 5.0之后这个包要手动安装。<br>安装完成后，使用如下使用，可察看安装的版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v   </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>hexo 版本号，需要在 初始化一个新的网站后才能察看，具体可跳转至 ：</p><p>![]{<a href="https://cdn.jsdelivr.net/gh/smile-zhang/blog-image@master/20210729/WeChat251df7990b757757dbd1e549201cfca7.20jrurmm3wgw.png%7D">https://cdn.jsdelivr.net/gh/smile-zhang/blog-image@master/20210729/WeChat251df7990b757757dbd1e549201cfca7.20jrurmm3wgw.png}</a></p><h3 id="1-2-升级"><a href="#1-2-升级" class="headerlink" title="1.2 升级"></a>1.2 升级</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm-check-updates -g</span><br></pre></td></tr></table></figure><h3 id="1-3-卸载-hexo、node-、npm"><a href="#1-3-卸载-hexo、node-、npm" class="headerlink" title="1.3  卸载  hexo、node 、npm"></a>1.3  卸载  hexo、node 、npm</h3><p>hexo 安装失败或需要升级时，可能需要卸载 hexo，正常情况下使用下面这条命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd `which hexo`/../../..</span><br><span class="line"></span><br><span class="line">rm -rf ./hexo ./hexo-cli</span><br><span class="line"></span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>如果执行以上命令无法彻底卸载，可连同 node、npm一起卸载后，重新安装 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall node</span><br><span class="line">brew uninstall npm</span><br></pre></td></tr></table></figure><h2 id="2-初始化-与-个性化配置"><a href="#2-初始化-与-个性化配置" class="headerlink" title="2. 初始化 与 个性化配置"></a>2. 初始化 与 个性化配置</h2><h3 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h3><ol><li>请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br><span class="line">注：&lt;folder&gt; 用于指代：你选定的，作为博客主目录的文件夹。</span><br></pre></td></tr></table></figure></li><li>新建完成后，指定文件夹的目录如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></li><li><a href="https://hexo.io/zh-cn/docs/setup">文件与文件夹具体作用，可至官网查看</a><h3 id="2-2-个性化配置"><a href="#2-2-个性化配置" class="headerlink" title="2.2 个性化配置"></a>2.2 个性化配置</h3>本文主要针对 hexo 的nexT主题进行配置，读者可根据个人喜好选择不同主题，方法大同小异。</li><li>创建 tags<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ hexo new page &quot;tags&quot;</span><br><span class="line">$ cd &lt;folder&gt;/source/tags</span><br><span class="line">$ vim index.md</span><br><span class="line">在文件底部插入代码 ：type: &quot;tags&quot;，修改完毕后，内容如下：</span><br><span class="line">  1 ---</span><br><span class="line">  2 title: tags</span><br><span class="line">  3 date: 2021-08-02 11:11:42</span><br><span class="line">  4 type: &quot;tags&quot;</span><br><span class="line">  5 ---</span><br><span class="line">$ ：wq 保存</span><br></pre></td></tr></table></figure></li><li>创建 categories<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ hexo new page &quot;categories&quot;</span><br><span class="line">$ cd &lt;folder&gt;/source/categories</span><br><span class="line">$ vim index.md</span><br><span class="line">在文件底部插入代码 ：type: &quot;tags&quot;，修改完毕后，内容如下：</span><br><span class="line">  1 ---</span><br><span class="line">  2 title: categories</span><br><span class="line">  3 date: 2021-08-02 11:11:42</span><br><span class="line">  4 type: &quot;categories&quot;</span><br><span class="line">  5 ---</span><br><span class="line">$ ：wq 保存</span><br></pre></td></tr></table></figure></li><li> 修改主题<br>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</li></ol><ul><li>下载主题  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li><li>启用主题<br>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。</li><li>验证主题<br>首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug。在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。<br>此时即可使用浏览器访问 <a href="http://localhost:4000，检查站点是否正确运行">http://localhost:4000，检查站点是否正确运行</a>.<br><img src="https://theme-next.iissnan.com/uploads/five-minutes-setup/validation-default-scheme-mac.png"></li></ul><ol start="4"><li><p>修改 背景透明度 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site/themes/next/source/css/_custom/custom.styl</span><br><span class="line">$ vim custom.styl</span><br><span class="line">编辑文件，增加如下内容：</span><br><span class="line">1 // Custom styles.</span><br><span class="line">  2 .header-inner&#123;</span><br><span class="line">  3   opacity: 0.8;</span><br><span class="line">  4 &#125;</span><br><span class="line">  5 .header-inner&#123;</span><br><span class="line">  6         opacity: 0.8;</span><br><span class="line">  7         z-index: 10;</span><br><span class="line">  8 &#125;</span><br></pre></td></tr></table></figure></li><li><p>设置 自动折叠<br>NexT 主题目录下 _config.yml 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site/themes/next/</span><br><span class="line">$ vim _config.yml</span><br><span class="line">修改为 ：</span><br><span class="line">auto_excerpt：</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></li><li><p>关闭 目录自动编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site/themes/next/</span><br><span class="line">$ vim _config.yml</span><br><span class="line">修改为 ：</span><br><span class="line">number ：false</span><br></pre></td></tr></table></figure></li><li><p>修改 界面布局，即修改界面宽度和留白</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim hexo/themes/next/source/css/_variables/Gemini.styl</span><br><span class="line">注：Gemini.styl 可替换为你当前使用的scheme 的文件名称</span><br><span class="line">// Settings for some of the most global styles.</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">$body-bg-color                    = #eee</span><br><span class="line">$main-desktop                     = 90%      //代表整体占用浏览器界面的百分比，即控制留白大小</span><br><span class="line">$sidebar-desktop                  = 240px   //侧边栏出现的位置</span><br><span class="line">$content-desktop                  = calc(100% - 250px)    //内容占用的大小</span><br></pre></td></tr></table></figure></li><li><p>设置 文章目录自动全展开  </p></li></ol><ul><li>Next主题写文章时, 只有当你浏览到相应的目录级时才会展开。想通过目录快速定位某段文章的时候就很不方便修改如下:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vim hexo/themes/next/source/css/_common/components/sidebar/sidebar-toc.styl</span><br><span class="line"></span><br><span class="line">找到如下的代码：</span><br><span class="line">.post-toc .nav .nav-child &#123; display: none; &#125;</span><br><span class="line">修改为：</span><br><span class="line">.post-toc .nav .nav-child &#123; display: block; &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>文章目录展开后，可能出现无法点击跳转到指定位置的bug，修复方法如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site/themes/next/source/js/src</span><br><span class="line">$ vim post-details.js</span><br><span class="line">找到第 73 行为目录绑定点击事件的方法，会看到：</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/smile-zhang/blog-image@master/20210729/image.7ki2zvbe2d80.png" alt="如图：">  </p><ul><li><p>targetSelector就是对应标题的 id，我们在他被塞到选择器之前重新编码一下：<br>// 对获取到的url进行重编码  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetSelector = decodeURI(this.getAttribute(&#x27;href&#x27;))</span><br></pre></td></tr></table></figure></li><li><p>然后 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code> 重新跑一下，发现目录就正常了</p></li></ul><ol start="9"><li>安装 搜索插件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site/</span><br><span class="line">$ npm install hexo-generator-search</span><br><span class="line">$ vim hexo/themes/next/themes/next/_config.yml</span><br><span class="line">修改：</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  trigger: manual   #手动，按回车键或搜索按钮触发搜索</span><br></pre></td></tr></table></figure></li><li>设置侧边栏，友情连接，只显示图标</li><li>安装 hexo git 插件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site/</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li>修改头像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site/themes/next/</span><br><span class="line">$ vim _config.yml</span><br><span class="line">文件中内容修改为: </span><br><span class="line"> # Sidebar Avatar,value 可以为本地目录下的图片文件，也可以是网络图片的链接</span><br><span class="line">avatar: /imgae/tx.img</span><br></pre></td></tr></table></figure></li><li>修改浏览器标签页图标与title<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">title：</span><br><span class="line">$ cd your-hexo-site</span><br><span class="line">$ vim _config.yml</span><br><span class="line">文件中内容修改为: </span><br><span class="line"># Site</span><br><span class="line">title: your Blog</span><br><span class="line"></span><br><span class="line">图标：</span><br><span class="line">$ cd your-hexo-site/themes/next/</span><br><span class="line">$ vim _config.yml</span><br><span class="line">文件中内容修改为: </span><br><span class="line">favicon:</span><br><span class="line">    small: /images/your icon.svg</span><br><span class="line">    medium: /images/your icon.svg</span><br></pre></td></tr></table></figure></li><li>关联到github 仓库<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site/</span><br><span class="line">$ vim _config.yml</span><br><span class="line">打开hexo 创建 的目录下的 _config.yml,文件底部修改为: </span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: your github repository</span><br><span class="line">  branch: master </span><br></pre></td></tr></table></figure><h2 id="3-基础命令"><a href="#3-基础命令" class="headerlink" title="3. 基础命令"></a>3. 基础命令</h2><h3 id="3-1-新建网站"><a href="#3-1-新建网站" class="headerlink" title="3.1 新建网站"></a>3.1 新建网站</h3>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-新建文章"><a href="#3-2-新建文章" class="headerlink" title="3.2 新建文章"></a>3.2 新建文章</h3><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3生成静态文件"><a href="#3-3生成静态文件" class="headerlink" title="3.3生成静态文件"></a>3.3生成静态文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ $ hexo generate</span><br><span class="line">该命令可以简写为</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="3-4-启动-hexo-服务器"><a href="#3-4-启动-hexo-服务器" class="headerlink" title="3.4 启动 hexo 服务器"></a>3.4 启动 hexo 服务器</h3><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ $ hexo server</span><br><span class="line">该命令可以简写为</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="3-5-更多hexo命令"><a href="#3-5-更多hexo命令" class="headerlink" title="3.5 更多hexo命令"></a>3.5 更多hexo命令</h3><p><a href="https://hexo.io/zh-cn/docs/commands.html#server">更多hexo命令请参考</a></p><p>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</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> node </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发相关</title>
      <link href="/2021/07/30/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/07/30/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="基本多线程的实现方式"><a href="#基本多线程的实现方式" class="headerlink" title="基本多线程的实现方式"></a>基本多线程的实现方式</h3><ol><li>继承Thread 类</li><li>实现Runnable 接口</li><li>实现Callable 接口 -&gt; 有返回值<br>get() 获取返回值会阻塞主线程<span id="more"></span></li></ol><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ol><li><p>newCachedThreadPool<br>根据需要来创建新线程的线程池.长时间 不使用的线程会终止,并从缓存移除. <strong>适合 执行很多短期异步任务的程序.</strong> 调用execute 方法来使用以前创建好的线程.如果没有可用的线程,就创建一个线程.</p></li><li><p>newFixedThreadPool<br>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中</p></li><li><p>newScheduledThreadPool<br>用于执行定时 或 延时 任务的线程池</p></li><li><p>newSingleThreadExecutor<br>创建 ** 只有一个线程的线程池** ,以无界队列的方式来运行该线程,即所有任务都由一个线程来完成,可以保证有序的执行各个任务 .如果这个线程在任务执行期间因为失败(或异常)被终止了,如果需要,可以开启一个新的线程代替它继续执行任务</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2021/07/30/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/07/30/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>引言：</p><h3 id="策略模式的概念"><a href="#策略模式的概念" class="headerlink" title="策略模式的概念"></a>策略模式的概念</h3><ol><li>对象具体某种行为，但是在不同的场景中，该行为有不同的算法实现。  </li><li>针对一种算法，将每一个算法封装到具有共同接口的独立类中，从而使用他们可以相互替换。  </li><li>策略模式使得算法可以在不影响到客户端的情况下发生变化。</li><li>可以替代代码中大量的 if-else，在《阿里巴巴Java开发手册》中有提到当超过 3 层的 if-else 的逻辑判断代码可以使用策略模式来实现。</li></ol><h3 id="策略模式的结构"><a href="#策略模式的结构" class="headerlink" title="策略模式的结构"></a>策略模式的结构</h3><p>策略模式是对算法的<strong>包装</strong>，是把使用<strong>算法的责任</strong>和<strong>算法本身</strong>分割开来，委派给<strong>不同的对象管理</strong>。策略模式通常把一个系列的算法包装到一系列的<strong>策略类</strong>里面，作为一个<strong>抽象策略类的子类</strong>。<br>用一句话来说 就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。<br><img src="https://raw.githubusercontent.com/smile-zhang/blog-image/master/20210729/1627468376374.136m0b4djf28.jpg"></p><h3 id="策略模式的代码实现-（基于spring）"><a href="#策略模式的代码实现-（基于spring）" class="headerlink" title="策略模式的代码实现 （基于spring）"></a>策略模式的代码实现 （基于spring）</h3><p>–</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客模版（mac 环境 ）</title>
      <link href="/2021/06/30/%E4%B8%BB%E9%A2%98/"/>
      <url>/2021/06/30/%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h2 id="2-基础（涉及）"><a href="#2-基础（涉及）" class="headerlink" title="2. 基础（涉及）"></a>2. 基础（涉及）</h2><h2 id="3-展开（论述）"><a href="#3-展开（论述）" class="headerlink" title="3. 展开（论述）"></a>3. 展开（论述）</h2><h2 id="4-解决（方案）"><a href="#4-解决（方案）" class="headerlink" title="4. 解决（方案）"></a>4. 解决（方案）</h2><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java锁机制</title>
      <link href="/2021/06/30/java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/06/30/java%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>锁，一种保护机制，在多线程的情况下，保证操作数据的正确性/一致性。不光在java语言中，各种开发语言，工具，中间件都有锁的概念与实现。<span id="more"></span></p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="公平锁和非公平锁-获取锁的方式"><a href="#公平锁和非公平锁-获取锁的方式" class="headerlink" title="公平锁和非公平锁(获取锁的方式)"></a>公平锁和非公平锁(获取锁的方式)</h3><ol><li>公平锁是指 按照申请锁的顺序来获取锁 </li><li>非公平锁是指锁的获取不是按照申请顺序来的,可能后申请的线程先拿到锁,这就可能出来优先级反转和馋饥饿现象(因为拿不到资源(锁)而不能继续执行).  </li><li>Synchronized 就是一种公平锁,因为它不是通过 aqs来实现现在调度的,所以任何办法能使它转变为 公平锁  </li><li>ReentrantLock 可以通过构造函数来决定是不是公平锁,默认是非公平锁  </li></ol><h3 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h3><ol><li>顾名思义 独享锁就是同时只能的一个线程持有, 而共享锁同时可以有多个线程一起持有  </li><li>Synchronized 就是一种独享锁  </li></ol><ul><li>lock 接口的 实现 : reentrantLock也是一种独享锁,非readWritLock其读锁是共享锁,写锁是独享锁. 其中读锁在高并发下是非常高效的.读写\写读\写写是互斥的  </li></ul><h3 id="互斥锁-读写锁-锁的实现-对于独享锁-共享锁"><a href="#互斥锁-读写锁-锁的实现-对于独享锁-共享锁" class="headerlink" title="互斥锁/读写锁(锁的实现 对于独享锁/共享锁)"></a>互斥锁/读写锁(锁的实现 对于独享锁/共享锁)</h3><h3 id="乐观锁-悲观锁-如何看待并发"><a href="#乐观锁-悲观锁-如何看待并发" class="headerlink" title="乐观锁/悲观锁(如何看待并发)"></a>乐观锁/悲观锁(如何看待并发)</h3><ul><li>悲观锁认为 : 对同一个数据(资源)的操作,必定是会有并发修改(冲突)的,即使没有,也认为有,所以对于一次数据操作,悲观锁必定采用加锁操,悲观的认为 不加锁的操作一定会出问题  </li><li>乐观锁认为 : 乐观的认为 不加锁的操作不会出总是, 所以乐观锁是采用无锁编程,常常采用cas算法. 伪代码如下 :  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.查询数据库,查询结果version=1</span><br><span class="line">2.执行更新,在sql where条件中判断 当前 数据中version是否等于一,</span><br><span class="line">3.如果等于1表示没有并发,更新成功</span><br><span class="line">4.如果当前数据中 version已经不等于1 ,则递归执行此方法,直到查询的version和更新时的version相等</span><br></pre></td></tr></table></figure></li></ul><h3 id="分段锁-锁的设计"><a href="#分段锁-锁的设计" class="headerlink" title="分段锁(锁的设计)"></a>分段锁(锁的设计)</h3><ul><li>是一种锁的设计方式,典型的如 concurrentHashMap中的put操作,它就是把Node数组中的一个元素(node节点)加锁,当其它实例想要执行put操作时,会先尝试获取锁,如果当前node已经做为锁被其它线程持有了,那线程进行等待  </li><li>偏向锁/轻量级锁/重量级锁 (锁的状态)  </li></ul><h3 id="自旋锁-Java中的自旋锁"><a href="#自旋锁-Java中的自旋锁" class="headerlink" title="自旋锁(Java中的自旋锁)"></a>自旋锁(Java中的自旋锁)</h3><p>是指线程如果获取不到锁,不会立即阻塞,而是通过循环的方式去尝试获取锁,这样做的好像是,减少线程上下文切换的消耗,缺点是循环会消耗cpu.</p><h3 id="自旋锁的升级"><a href="#自旋锁的升级" class="headerlink" title="自旋锁的升级"></a>自旋锁的升级</h3><ul><li>可重入  : 引入计数器,如果当前线程又一次执行lock方法,想要获取锁,比较正在持有锁的线程和当前线程,如果一致,则计数器+1 , unlock 方法反之</li><li>公平锁 : 引入服务号和排队号,即每个线程执行lock方法时,排队号+1,unlocak时服务号+1, 线程的循环等待中 ,判断自己的排队号和服务号一致,则获取锁成功</li></ul><h2 id="synchronized-的两种用法"><a href="#synchronized-的两种用法" class="headerlink" title="synchronized 的两种用法"></a>synchronized 的两种用法</h2><h3 id="synchronized-修饰代码块"><a href="#synchronized-修饰代码块" class="headerlink" title="synchronized 修饰代码块"></a>synchronized 修饰代码块</h3><p>在这个代码块被编译为字节码的时候,会在同步块的入口位置和退出位置增加 monitorenter 和monitorexit 指令</p><h3 id="synchronized-修饰方法"><a href="#synchronized-修饰方法" class="headerlink" title="synchronized 修饰方法"></a>synchronized 修饰方法</h3><p>在class文件的方法表中,这个方法的 access_flags 字段中的 snychrnized 标识位改为1</p><blockquote><p>JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的,使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行.这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境（无锁竞争环境）如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销</p></blockquote><h3 id="synchronized-修饰静态方法"><a href="#synchronized-修饰静态方法" class="headerlink" title="synchronized 修饰静态方法"></a>synchronized 修饰静态方法</h3><h2 id="redis-分布式锁"><a href="#redis-分布式锁" class="headerlink" title="redis 分布式锁"></a>redis 分布式锁</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><ul><li>当前锁是否有人持有</li><li>如果当前锁有人持有,判断是否超时</li><li>无人持有,或已经超时,但未被删除(未unlocl)时, 也可以获得锁</li></ul><h3 id="unloac"><a href="#unloac" class="headerlink" title="unloac"></a>unloac</h3><ul><li>解锁之前,判断自己持有的锁是否超时了,如果超时,不重复解锁</li></ul><h2 id="自旋锁的实现与升级"><a href="#自旋锁的实现与升级" class="headerlink" title="自旋锁的实现与升级"></a>自旋锁的实现与升级</h2>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 锁 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
